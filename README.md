
---

**Студент:** Крохин Роман Олегович  
**ИСУ:** 368381  
**Группа:** P3324  
**Университет:** НИУ ИТМО  
**Факультет:** Программная инженерия и компьютерная техника  
**Курс:** 3-й курс  

---

# Отчет по лабораторной работе: Реализация неизменяемого мешка (Separate Chaining Hashmap)

## Цель

Цель данной лабораторной работы — освоиться с построением пользовательских типов данных, полиморфизмом, рекурсивными алгоритмами и средствами тестирования (unit testing, property-based testing). В рамках работы была реализована структура данных — неизменяемый мешок (hash bag), использующий метод отдельной цепочки (separate chaining).

## Требования к разработанному ПО

1. Реализовать функции:
   - добавление и удаление элементов;
   - фильтрация;
   - отображение (map);
   - свертки (левая и правая);
   - структура должна быть моноидом.

2. Структуры данных должны быть неизменяемыми.
3. Библиотека должна быть протестирована в рамках unit testing.
4. Библиотека должна быть протестирована в рамках property-based testing (как минимум 3 свойства, включая свойства моноида).
5. Структура должна быть полиморфной.
6. Использовать идиоматичный для технологии стиль программирования.

## Ключевые элементы реализации

### Определение структуры данных

Создание пустого мешка с использованием отдельной цепочки:

```clojure
(defn create-bag []
  {})
```

### Добавление элемента

Функция `add-to-bag` добавляет элемент в мешок. Для этого используется функция `update`, которая создает новый мешок с добавленным элементом:

```clojure
(defn add-to-bag [bag key element]
  (update bag (hash key) #(conj (or % []) element)))
```

### Удаление элемента

Функция `remove-one-from-bag` удаляет один элемент из мешка. Она возвращает новый мешок без изменяемых данных:

```clojure
(defn remove-one-from-bag [bag key element]
  (let [hash-key (hash key)
        current-list (get bag hash-key [])]
    (if (empty? current-list)
      bag
      (let [new-list (rest (drop-while #(not= % element) current-list))]
        (if (empty? new-list)
          (dissoc bag hash-key)
          (assoc bag hash-key new-list))))))
```

### Фильтрация

Функция `filter-bag` фильтрует элементы в мешке по заданному предикату и возвращает новый мешок:

```clojure
(defn filter-bag [bag pred]
  (into {} (map (fn [[k v]] [k (filter pred v)]) bag)))
```

### Отображение (map)

Функция `map-bag` применяет функцию к элементам мешка и возвращает новый мешок:

```clojure
(defn map-bag [bag f]
  (reduce
   (fn [new-bag [k v]]
     (assoc new-bag k (map f v)))
   empty-bag
   bag))
```

### Свертки

Слевая и правая свертки реализованы в функциях `fold-left` и `fold-right` соответственно:

```clojure
;; Слевая свёртка (fold-left)
(defn fold-left [bag f init]
  (reduce
   (fn [acc [k v]]
     (reduce #(f %1 %2) acc v))
   init
   bag))

;; Справа свёртка (fold-right)
(defn fold-right [bag f init]
  (reduce
   (fn [acc [k v]]
     (reduce #(f %2 %1) acc (reverse v)))
   init
   bag))
```

### Неизменяемость

Коллекция неизменяемая, поскольку все функции возвращают новые структуры данных без изменения исходного мешка. Например, `add-to-bag` возвращает новый мешок с добавленным элементом, а `remove-one-from-bag` возвращает новый мешок с удаленным элементом:

```clojure
(def empty-bag
  (create-bag))
```

Каждая операция возвращает новую версию мешка, а исходный мешок остается неизменным.

## Тестирование

### Unit Testing

Для тестирования были реализованы следующие [тесты](lab2/test/core_test.clj)

### Property-Based Testing

Были протестированы [свойства](lab2/test/core_property_test.clj)

## Выводы

В ходе реализации лабораторной работы был изучен процесс создания неизменяемых структур данных на языке Clojure. Реализация мешка с использованием метода отдельной цепочки позволила углубить понимание работы хеш-таблиц и полиморфизма. Использование спецификаций и свойств для тестирования обеспечило надежность и стабильность библиотеки, позволяя уверенно добавлять новые функции.
